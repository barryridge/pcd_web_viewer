<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="content-type" content="text/html; charset=UTF-8">
		<meta charset="utf-8">
		<title>Pointcloud Viewer</title>
		<link href="css/bootstrap.min.css" rel="stylesheet">
		<!--[if lt IE 9]>
			<script src="//html5shim.googlecode.com/svn/trunk/html5.js"></script>
		<![endif]-->
		<style>
			body {margin:0; padding:0; background-color:black}
			canvas {width:100%; height:100%;}
		</style>
	</head>

	<body>
		<script src="js/jquery.min.js"></script>
		<script src="js/bootstrap.min.js"></script>
		<script src="js/webgl-detector.js"></script>
		<script src="js/three.min.js"></script>
		<script src="js/TrackballControls.js"></script>
		<script src="js/OrbitControls.js"></script>
		<script src="js/jquery.binarytransport.js"></script>
		<script src="js/stream.js"></script>
		<script src="js/load_bin_file.js"></script>
		<script>
			var getUrlParameter = function getUrlParameter(sParam) {
				var sPageURL = decodeURIComponent(window.location.search.substring(1)),
					sURLVariables = sPageURL.split('&'),
					sParameterName,
					i;

				for (i = 0; i < sURLVariables.length; i++) {
					sParameterName = sURLVariables[i].split('=');

					if (sParameterName[0] === sParam) {
						return sParameterName[1] === undefined ? true : sParameterName[1];
					}
				}
			};



			// Convert colors
			function colorToHex(color) {
				if (color.substr(0, 1) === '0x') {
				return color;
				}
				var digits = /(.*?)rgb\((\d+),(\d+),(\d+)\)/.exec(color);

				var red = parseInt(digits[2]);
				var green = parseInt(digits[3]);
				var blue = parseInt(digits[4]);

				var rgb = blue | (green << 8) | (red << 16);
				return digits[1] + '0x' + rgb.toString(16);
			}

			// Build a color
			function buildColor(v){
				var pi = 3.151592;
				var r = Math.cos(v*2*pi + 0) * 0.5 + 0.5;
				var g = Math.cos(v*2*pi + 2) * 0.5 + 0.5;
				var b = Math.cos(v*2*pi + 4) * 0.5 + 0.5;

				return new THREE.Color(r, g, b);
			}

			var scene = null;
			var renderer = null;
			var camera = null;

			// When page loads
			$(function() {

				// Draw the progressbar on the middle
				var left = Math.round( (window.innerWidth - 400)/2 );
				$("#progressbar-container").css("left",left + "px");

				// Scene
				scene = new THREE.Scene();
				scene.fog = new THREE.FogExp2(0x000000, 0.0009);

				// Camera
				var camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 300);
				camera.position.z = 8;
				camera.up = new THREE.Vector3(0,0,1);

				// Detect webgl support
				if (!Detector.webgl) {
					$("#progressbar-container").hide();
					Detector.addGetWebGLMessage();
					return;
				}

				// The renderer
				renderer = new THREE.WebGLRenderer();
				renderer.setSize(window.innerWidth,window.innerHeight -4);

				// Render the scene
				function render() {
					renderer.render(scene, camera);
				}

				// Setup controls
				var controls = new THREE.OrbitControls( camera );
				controls.rotateSpeed = 1.0;
				controls.zoomSpeed = 10.2;
				controls.panSpeed = 0.8;
				controls.enableDamping = true;
				controls.dampingFactor = 0.3;
				controls.keys = [65, 17, 18];
				controls.addEventListener('change', render);

				// Render loop
				function animate() {
					requestAnimationFrame(animate);
					controls.update();
				}

				// Init the geometry
				var pointSize = getUrlParameter('pointSize');
				if(pointSize)
					pointSize = parseFloat(pointSize);
				else
					pointSize = 0.015;

				var geometry = new THREE.Geometry();
				var material = new THREE.PointsMaterial({size:pointSize, vertexColors:true});
				var pointcloud = new THREE.Points(geometry, material);
				scene.add(pointcloud);

				// Add the canvas, render and animate
				var container = document.getElementById('container');
				container.appendChild(renderer.domElement);

				// Load the pointcloud
				var colors = {
					x: {
						data: [],
						valid: 0
					},
					y: {
						data: [],
						valid: 0
					},
					z: {
						data: [],
						valid: 0
					},
					rgb: {
						data: [],
						valid: 0
					}
				};

				var cname = getUrlParameter('color');
				if(cname == undefined)
					cname = 'rgb';

				function recomputeColorChannel(name, stats, numPoints) {
					stats = stats[name];

					if(stats.min >= stats.max)
						return;

					var data = colors[name].data;

					var start = stats.dirty ? 0 : colors[name].valid;
					if(stats.dirty)
						console.log('color channel dirty');

					for (var i=start; i < numPoints; i++)
					{
						var z = geometry.vertices[i][name];
						t = (z-stats.min)/(stats.max-stats.min);
						if(isNaN(t))
						{
							data[i] = new THREE.Color(0);
							continue;
						}
						data[i] = buildColor(t);
					}

					// Extend to vertices.length
					for(var i = numPoints; i < geometry.vertices.length; ++i)
						data[i] = new THREE.Color(0.87, 0.87, 0.87);

					colors[name].valid = numPoints;
				};

				// Changes the color of the points
				function changeColor(color_mode)
				{
					console.log('Switching to color mode', color_mode);

					if(colors[color_mode].valid != geometry.vertices.length)
					{
						recomputeColorChannel(color_mode, finalStats, geometry.vertices.length);
					}

					pointcloud.geometry.colors = colors[color_mode].data;
					pointcloud.geometry.colorsNeedUpdate = true;
				}

				// Handle colors and pointsize
				function onKeyDown(evt) {
					// Increase/decrease point size
					if (evt.keyCode == 189 || evt.keyCode == 109 || evt.keyCode == 173)
					{
						pointcloud.material.size -= 0.003;
						pointcloud.material.needsUpdate = true;
					}

					if (evt.keyCode == 187 || evt.keyCode == 107 || evt.keyCode == 171)
					{
						pointcloud.material.size += 0.003;
						pointcloud.material.needsUpdate = true;
					}

					if (evt.keyCode == 49) changeColor('x');
					if (evt.keyCode == 50) changeColor('y');
					if (evt.keyCode == 51) changeColor('z');
					if (evt.keyCode == 52) changeColor('rgb');

					render();
				}

				var bufferSize = 0;
				var finalStats = null;

				loadBinFile(getUrlParameter('load'), geometry.vertices, colors['rgb'].data,
					function(stats, numPoints) {
						colors['rgb'].valid = numPoints;
						finalStats = stats;

						if(cname != 'rgb')
							recomputeColorChannel(cname, stats, numPoints);

						console.log('progress', numPoints);

						// If the geometry buffer size changed, we need to
						// recreate the geometry.
						if(geometry.vertices.length != bufferSize) {
							scene.remove(pointcloud);
							pointcloud.geometry.dispose();
							pointcloud.material.dispose();

							var vertices = geometry.vertices;

							geometry = new THREE.Geometry();
							geometry.dynamic = true;
							geometry.vertices = vertices;
							geometry.colors = colors[cname].data;

							console.log('colors:', numPoints, geometry.colors.length);

							pointcloud = new THREE.Points(geometry, material);
							scene.add(pointcloud);
						}
						else
						{
							geometry.verticesNeedUpdate = true;
							geometry.colorsNeedUpdate = true;
						}

						bufferSize = geometry.vertices.length;

						render();
					},
					function() {
						// Remove the progressbar
						$("#progressbar-container").hide();
						$("#controls-browser").show();
						document.addEventListener("keydown", onKeyDown, false);
					}
				);

				render();
				animate();
			});
		</script>

		<div id="container" style="width:100%; height:100%; position:relative;">
			<div id="controls-browser" style="position:absolute; top:5px; left:5px; z-index:999999; display:none;">
				<p style="color:#aaa; margin-top:5px; font-size:12px;">
				- 1, 2, 3 &amp; 4 change color<br />
				- +/- change point size
				</p>
			</div>

			<div id="progressbar-container" class="progress progress-striped" style="position:absolute; z-index:999999; width:400px; top:230px;">
				<div id="progressbar" class="progress-bar progress-bar-info" role="progressbar" aria-valuenow="3" aria-valuemin="0" aria-valuemax="100" style="width:3%">3%</div>
			</div>
		</div>
  </body>
</html>

